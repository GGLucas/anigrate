#!/usr/bin/env python2
import sys
import os
import datetime

from decorator import decorator

from sqlalchemy import Column, Integer, String, ForeignKey, DateTime, Boolean, create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

# {{{ Help
"""
Usage Examples
--------------

ani new anime: clannad -- Adds a series with a season
ani watch: clannad -- Increments episode count, adds a season if last ep
ani watch +3: clannad -- Watch 3 episodes on clannad's current season
ani rate 8: clannad -- Set score
ani drop: clannad -- Set dropped
ani undrop: clannad -- Set undropped
ani season add: clannad -- Add a new season
ani season add 8: clannad -- Add season with number 8
ani season remove: clannad -- Remove current season
ani season remove 1: clannad -- Remove season 1
ani season active 4: clannad -- Set active season
ani season length 4 24: clannad -- Set season 4 length 24
ani length 24: clannad -- Set current season length 24
"""

HELPTEXT = """
Usage: %s [COMMAND] [ARGS...]: [SELECTOR]
Manage list of watched anime and television series.

Database:
    By default anigrate uses an sqlite database in $HOME/.anigrate/db,
    see the example anigraterc for all the other possibilities.

Commands:
    initdb
        Initialise the database with all the necessary tables.

    list [category]: (selector)
        List all series in [category] matched by (selector).
        If no selector is given, match all series in [category].
        If no category is given, match series in any category.

    log: (selector)
        Show a detailed log for series matching (selector).

    add [category]: (selector)
        Add a new series entry with name specified by (selector).
        Optionally you can enter a category to mark it as.

    remove: (selector)
        Completely remove any series that match (selector).

    rate <score>: (selector)
        Rate all series matched by (selector) with <score>.

    [un]drop: (selector)
        Mark all series matched by (selector) as dropped or not dropped.

    length <length>: [selector]
        Set the active season's length in episodes.

    watch [num]: (selector)
        Change the episodes watched count. Without [num] specified it will be
        incremented by one. Using specifiers like "+3" or "-2" you can increment
        or decrement the watched count by that number. Specifying an absolute
        number will watch up to that episode or remove everything from that
        episode on. Watch always uses the currently active season.

    season add [num]: [selector]
        Add a new season, if num is specified the season number is set to that, 
        otherwise it will default to one more than the previous season.

    season remove [num]: [selector]
        Remove the season with number [num] from a series. If num is not
        specified the currently active season will be removed.

    season length <season> <length>: [selector]
        Set a season's length in episodes.

    season active <num>: [selector]
        Set season with number <num> as the active season. Can be a relative 
        offset like +1 or -2.

"""
# }}}

# {{{ Constants
CONF_DIR = os.getenv("HOME")+"/.anigrate"
DB_LOCATION = CONF_DIR+"/db"

COLOR = {
    "normal": "\033[0m",
    "unknown": "\033[1;35m",
    "header": "\033[1;33m",

    "series_watching": "\033[1;34m",
    "series_dropped": "\033[1;31m",

    "score_top": "\033[1;32m",
    "score_high": "\033[0;32m",
    "score_normal": "\033[0;37m",
    "score_low": "\033[0;31m",
    "score_critical": "\033[1;31m",
}

DISPLAY_HEADER = \
"""\n  %(header)sSeries%(normal)s                                   | %(header)sWatched%(normal)s | %(header)sSeason%(normal)s | %(header)sRating%(normal)s """ % COLOR+\
"""\n ------------------------------------------|---------|--------|--------"""

DISPLAY_FOOTER = """                                           |         |        |        \n"""

DISPLAY_SERIES = """  %(title)s | %(epscurrent)s/%(epstotal)s | %(current)s | %(rating)s """
# }}}

# {{{ Models
Base = declarative_base()
Session = sessionmaker()

class Series(Base):
    """An entire series."""
    __tablename__ = "series"
    id = Column(Integer, primary_key=True)
    rating = Column(Integer, default=0)
    title = Column(String(255))

    current = Column(Integer)
    ctime = Column(DateTime)
    mtime = Column(DateTime)
    dropped = Column(Boolean, default=False)
    category = Column(String(255), default="")
    duration = Column(Integer, default=22)
    finished = Column(Boolean, default=False)

    seasontotal = Column(Integer, default=1)
    epscurrent = Column(Integer, default=0)
    epstotal = Column(Integer, default=0)

    def getseason(self, session, num=None):
        """Retrieve a season based on its number."""
        return session.query(Season).filter(
            Season.series == self.id
        ).filter(
            Season.num == (self.current if num==None else num)
        ).first()

    def eval_finished(self, session):
        """Evaluate whether the series is finished."""
        self.finished = True
        self.seasontotal = 0

        for season in session.query(Season).filter(
                Season.series == self.id).all():
            if season.current_watched < season.episode_total \
            or season.episode_total == 0:
                self.finished = False

            if season.num == self.current:
                self.epscurrent = season.current_watched
                self.epstotal = season.episode_total

            self.seasontotal += 1

        return self.finished

class Season(Base):
    """One season of a series."""
    __tablename__ = "seasons"
    id = Column(Integer, primary_key=True)
    num = Column(Integer)

    series = Column(ForeignKey("series.id"))
    episode_total = Column(Integer, default=0)
    current_watched = Column(Integer, default=0)

class Watched(Base):
    """A 'watched episodes' event attached to a season."""
    __tablename__ = "watched"
    id = Column(Integer, primary_key=True)

    season = Column(ForeignKey("seasons.id"))
    time = Column(DateTime)

    startep = Column(Integer)
    finishep = Column(Integer)
# }}}

# {{{ Utility functions
commands = {}

def command(name=None, cmds=None):
    """Register a function as a command."""
    def cmd(func):
        # Get command dict
        if cmds == None:
            global commands
            cm = commands
        else:
            cm = cmds

        cm[(name or func.__name__)] = func
        return func

    return cmd

def getcommand(name, cmds=None):
    """Get a command by name."""
    # Get command dict
    if cmds == None:
        global commands
        cmd = commands
    else:
        cmd = cmds

    # Exact match
    if name in cmd:
        return cmd[name]

    # Prefix match
    candidate = filter(lambda x: x.startswith(name), cmd.keys())

    if len(candidate) == 1:
        return cmd[candidate[0]]
    elif candidate:
        return candidate
    else:
        return None

def dbbind():
    """Bind the sqlalchemy database engine and return the session."""
    if not os.access(CONF_DIR, os.F_OK):
        os.mkdir(CONF_DIR)

    engine = create_engine('sqlite:///'+DB_LOCATION)
    Base.metadata.bind = engine
    Session.configure(bind=engine)

    if not os.access(DB_LOCATION, os.F_OK):
        initdb(session=Session())

    return Session()

def getselection(session, selector, list=True):
    """Get all anime matching a selector"""
    query = session.query(Series).filter(Series.title.startswith(selector))
    return query.all() if list else query

def padstr(string, pad, right=False):
    # Convert to string
    string = str(string)

    # Padd
    while len(string) < pad:
        if right:
            string = " "+string
        else:
            string = string+" "

    return string

# }}}

# {{{ Display functions
def dispseries(sel, display=True):
    """Display a line for a series."""
    data = {
        "title": sel.title,
        "current": padstr(sel.current, 6),
        "epscurrent": padstr(sel.epscurrent, 3),
        "epstotal": padstr(sel.epstotal, 3, right=True),
        "rating": padstr(sel.rating, 6),
    }

    # Color rating
    if sel.rating == 0:
        data['rating'] = COLOR['unknown']+"??    "+COLOR['normal']
    elif sel.rating <= 4:
        data['rating'] = COLOR['score_critical']+data['rating']+COLOR['normal']
    elif sel.rating <= 5:
        data['rating'] = COLOR['score_low']+data['rating']+COLOR['normal']
    elif sel.rating >= 10:
        data['rating'] = COLOR['score_top']+data['rating']+COLOR['normal']
    elif sel.rating >= 8:
        data['rating'] = COLOR['score_high']+data['rating']+COLOR['normal']

    # Dropped note
    if sel.dropped:
        data['title'] = "(dropped) "+data['title']

    # Truncate series
    if len(data['title']) > 40:
        data['title'] = data['title'][:37]+"..."

    data['title'] = padstr(data['title'], 40)

    if sel.epstotal == 0:
        data['epstotal'] = COLOR['unknown']+" ??"+COLOR['normal']

    # Mark watching/dropped
    if sel.dropped:
        data['title'] = COLOR['series_dropped']+data['title']+COLOR['normal']
        data['current'] = COLOR['series_dropped']+data['current']+COLOR['normal']
        data['epscurrent'] = COLOR['series_dropped']+data['epscurrent']
        data['epstotal'] = data['epstotal']+COLOR['normal']
    elif not sel.finished:
        data['title'] = COLOR['series_watching']+data['title']+COLOR['normal']
        data['current'] = COLOR['series_watching']+data['current']+COLOR['normal']
        data['epscurrent'] = COLOR['series_watching']+data['epscurrent']
        data['epstotal'] = data['epstotal']+COLOR['normal']

    if display:
        print(DISPLAY_SERIES % data)
    else:
        return DISPLAY_SERIES % data

# }}}

# {{{ Commands
# {{{ initdb
@command()
def initdb(arg=None, selector=None, session=None):
    """Initialise the database for use."""
    if not session:
        dbbind()
    Base.metadata.create_all()
# }}}

# {{{ add
@command()
def add(arg, selector):
    if not selector:
        print("Error: selector required.")
        return

    # Bind database
    session = dbbind()

    # Don't create if one already exists
    if session.query(Series).filter(Series.title == selector).all():
        print("Error: A series with this name already exists...")
        return

    # Create a new series
    series = Series(title=selector, current=1)
    series.ctime = datetime.datetime.now()
    series.mtime = datetime.datetime.now()

    session.add(series)
    session.commit()

    ## Category
    if arg:
        series.category = arg[0]

    ## First season
    season = Season(num=1)
    season.series = series.id

    print("Adding: %s..." % series.title)
    session.add(season)
    session.commit()
# }}}

# {{{ remove
@command()
def remove(arg, selector):
    """Remove a series in totality."""
    if not selector:
        return "Error: selector required."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    if not selection:
        return "Error: no series match selector."

    for sel in selection:
        print("Removing: %s..." % sel.title)

        for season in session.query(Season).filter(Season.series == sel.id).all():
            session.query(Watched).filter(Watched.season == season.id).delete(False)
            session.delete(season)

        session.delete(sel)

    session.commit()
# }}}

# {{{ rate
@command()
def rate(arg, selector):
    """Set the rating/score for a series."""
    if not selector:
        return "Error: selector required."

    if not arg:
        return "Error: rating required."

    try:
        score = int(arg[0])
    except:
        return "Error: rating is not a valid number."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    for sel in selection:
        print("Rating %d: %s..." %(score, sel.title))
        sel.rating = score

    session.commit()
# }}}
    
# {{{ [un]drop
@command()
def drop(arg, selector):
    """Drop a series."""
    if not selector:
        return "Error: selector required."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)


    if not selection:
        return "Error: no series match selector."

    for sel in selection:
        print("Dropping: %s..." % sel.title)
        sel.dropped = True

    session.commit()

@command()
def undrop(arg, selector):
    """Undrop a series."""
    if not selector:
        return "Error: selector required."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    for sel in selection:
        print("Undropping: %s..." % sel.title)
        sel.dropped = False

    session.commit()
# }}}

# {{{ length
@command()
def length(arg, selector):
    """Set the current season's length for a series."""
    if not selector:
        return "Error: selector required."

    if not arg:
        return "Error: length required."

    try:
        length = int(arg[0])
    except:
        return "Error: length is not a valid number."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    for sel in selection:
        season = sel.getseason(session)
        season.episode_total = length

        print("Setting season %d length to %d: %s..."%
                (season.num, length, sel.title))

        sel.eval_finished(session)

    session.commit()
# }}}

# {{{ season
global seasoncmd
seasoncmd = {}

@command()
def season(arg, selector):
    """Run a season command"""
    if not arg:
        return "Error: season command required."

    global seasoncmd
    cmd = getcommand(arg[0], cmds=seasoncmd)

    if callable(cmd):
        return cmd(arg[1:], selector)
    elif cmd:
        print("Error: ambiguous season command, available:")
        print("\n".join(("  %s season "+x)%sys.argv[0] for x in cmd))
        exit(1)
    else:
        return "Error: Invalid Season Command: %s" % arg[0]

# {{{ active
@command(cmds=seasoncmd)
def active(arg, selector):
    """Set the rating/score for a series."""
    if not selector:
        return "Error: selector required."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    # Get number
    if arg:
        try:
            rel = arg[0][0] in ('+', '-')
            num = int(arg[0])
        except:
            return "Error: season number is not a valid number."
    else:
        return "Error: season number required."

    if not selection:
        return "Error: no series match selector."

    for sel in selection:
        sn = sel.current+num if rel else num

        if sn < 1:
            print("Error: season number for series %s too low (%d)."
                    % (sel.title, sn))
            continue

        if not sel.getseason(session, sn):
            print("Error: season %d for series %s doesn't exist."
                    % (sn, sel.title))
            continue

        print("Activating season %d: %s..." % (sn, sel.title))
        season = sel.getseason(session, sn)
        sel.current = sn
        sel.eval_finished()

    session.commit()
# }}}

# {{{ add
@command(cmds=seasoncmd)
def add(arg, selector):
    """Set the rating/score for a series."""
    if not selector:
        return "Error: selector required."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    # Get number
    if arg:
        try:
            num = int(arg[0])
        except:
            return "Error: season number is not a valid number."
    else:
        num = None

    if not selection:
        return "Error: no series match selector."

    for sel in selection:
        sn = sel.current+1 if num==None else num

        if sn < 1:
            print("Error: season number for series %s too low (%d)."
                    % (sel.title, sn))
            continue

        if sel.getseason(session, sn):
            print("Error: season %d for series %s already exists."
                    % (sn, sel.title))
            continue

        season = Season()
        season.series = sel.id
        season.num = sn
        sel.current = season.num

        print("Adding season %d: %s..." % (sn, sel.title))
        session.add(season)
        sel.eval_finished(session)

    session.commit()
# }}}

# {{{ remove
@command(cmds=seasoncmd)
def remove(arg, selector):
    """Remove a season from a series."""
    if not selector:
        return "Error: selector required."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    # Get number
    if arg:
        try:
            num = int(arg[0])
        except:
            return "Error: season number is not a valid number."
    else:
        num = None

    if not selection:
        return "Error: no series match selector."

    for sel in selection:
        sn = sel.current if num==None else num

        if sn < 1:
            print("Error: season number for series %s too low (%d)."
                    % (sel.title, sn))
            continue

        # Find season
        season = sel.getseason(session, sn)

        # Check for existence
        if not season:
            print("Error: season %d for series %s doesn't exist."
                    % (sn, sel.title))
            continue

        # Delete watched
        session.query(Watched).filter(Watched.season == season.id).delete(False)

        # Delete
        print("Removing season %d: %s..." % (sn, sel.title))
        session.delete(season)

        if sel.current == sn:
            # Get new season number
            sn -= 1
            while sn > 0 and not sel.getseason(session, sn):
                sn -= 1
            sel.current = sn

        sel.eval_finished(session)


    session.commit()
# }}}

# {{{ length
@command(cmds=seasoncmd)
def length(arg, selector):
    """Set the current season's length for a series."""
    if not selector:
        return "Error: selector required."

    if len(arg) < 2:
        return "Error: insufficient arguments."

    try:
        num = int(arg[0])
    except:
        return "Error: season number is not a valid number."

    try:
        length = int(arg[0])
    except:
        return "Error: length is not a valid number."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    for sel in selection:
        season = sel.getseason(session, num)
        season.episode_total = length

        print("Setting season %d length to %d: %s..."%
                (num, length, sel.title))

        sel.eval_finished(session)

    session.commit()
# }}}

# }}}

# {{{ watch
@command()
def watch(arg, selector):
    """Set the watched count for the currently active season."""
    if not selector:
        return "Error: selector required."

    if arg:
        try:
            rel = arg[0][0] in ('+', '-')
            num = int(arg[0])
        except:
            return "Error: watched amount is not a valid number."
    else:
        rel = True
        num = 1

    # Filter out silly numbers
    if rel and num == 0:
        return "Error: invalid watched amount: 0."
    elif not rel and num < 0:
        return "Error: invalid watched amount: %d." % num

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    # Display header
    print(DISPLAY_HEADER)

    for sel in selection:
        season = sel.getseason(session)
        neww = season.current_watched+num if rel else num

        if neww < 0:
            return "Error: invalid watched amount %d: %s." % (neww, sel.title)
        if season.episode_total > 0 and neww > season.episode_total:
            return "Error: watched amount %d is more than season length %d: %s."\
                     % (neww, season.episode_total, sel.title)

        if neww < season.current_watched:
            watched = session.query(Watched).filter(
                Watched.season == season.id
            ).order_by(Watched.finishep.desc()).all()

            for inst in watched:
                if inst.startep >= neww:
                    session.delete(inst)
                elif inst.finishep > neww:
                    inst.finishep = neww
                    break
        elif neww > season.current_watched:
            watched = Watched()
            watched.season = season.id
            watched.startep = season.current_watched
            watched.finishep = neww
            watched.time = datetime.datetime.now()
            session.add(watched)

        sel.mtime = datetime.datetime.now()
        season.current_watched = neww

        # Check if season is finished
        if season.current_watched == season.episode_total \
        and season.episode_total != 0 \
        and sel.getseason(session, sel.current+1):
            sel.current = sel.current+1

        season = sel.getseason(session)
        sel.eval_finished(session)
        dispseries(sel)

    # Display footer
    print(DISPLAY_FOOTER)

    session.commit()
# }}}

# {{{ list
@command()
def list(arg, selector):
    """Display lines matching a selector."""
    # Bind database
    session = dbbind()

    # Get selection
    if selector:
        selection = getselection(session, selector, list=False)
    else:
        selection = session.query(Series)

    # Category
    if arg:
        selection = selection.filter(Series.category == arg[0])

    # Sort by completion
    selection = selection.order_by(
        Series.dropped.asc(), Series.finished.asc(), Series.mtime.desc())

    # Display header
    print(DISPLAY_HEADER)

    for sel in selection.all():
        dispseries(sel)

    # Display footer
    print(DISPLAY_FOOTER)
# }}}

# }}}

# {{{ Main function
def main():
    # Retrieve arguments
    arg = sys.argv[1:]

    # Intercept help
    if not arg or arg[0] in ("help", "--help", "-h"):
        print(HELPTEXT%sys.argv[0])
        return

    # Get selector and arguments
    ## Check if there exists a selector
    if filter(lambda x: x.endswith(":"), arg):
        selector = []

        # Build selector
        for i,x in enumerate(reversed(arg[1:])):
            if x.endswith(":"):
                break
            else:
                selector.insert(0, x)
                arg.remove(x)

        selector = " ".join(selector)

        # Remove colon
        arg[-1] = arg[-1][:-1]
    else:
        selector=None

    # Call the command
    cmd = getcommand(arg[0])

    if callable(cmd):
        res = cmd(arg[1:], selector)

        if res:
            # An error occured
            print(res)
            exit(1)
    elif cmd:
        print("Error: ambiguous command, available:")
        print("\n".join(("  %s "+x)%sys.argv[0] for x in cmd))
        exit(1)
    else:
        print("Error: Invalid Command: %s" % arg[0])
        print(HELPTEXT%sys.argv[0])
        exit(1)
# }}}

# Call main function
if __name__ == '__main__':
    main()
# vim: set fdm=marker :
