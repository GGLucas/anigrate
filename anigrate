#!/usr/bin/env python2
# coding=utf-8
import sys
import os
import datetime
import time
import csv

import gzip
import StringIO

from ConfigParser import ConfigParser
from urllib2 import quote, unquote

from sqlalchemy import Column, Integer, String, ForeignKey, DateTime, Boolean, create_engine
from sqlalchemy.orm import sessionmaker, relation
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.sql import and_, or_, not_

# Try to get flup
try:
    import flup
    HAVE_FLUP = True
except:
    HAVE_FLUP = False

# {{{ Constants
## Application info
ANIGRATE_URI = "http://anigrate.glacicle.org"
ANIGRATE_VERSION = 1.0

## Places
CONF_DIR = os.getenv("HOME")+"/.anigrate"
DB_LOCATION = CONF_DIR+"/db"
CONF_LOCATION = CONF_DIR+"/config"

## Default weblink titles
DEFAULT_TITLE_LIST = "Watch List"
DEFAULT_TITLE_LOG = "Watch Log"
DEFAULT_TITLE_STATS = "Watch Stats"
DEFAULT_LINK = "http://en.wikipedia.org/wiki/Special:Search?search=%s"

## Date formats
DATE_FORMAT = "%a %d %b, %Y {LINE} %H:%M"
DATE_FORMAT_HTML = "%a %d %b, %Y %H:%M"

## Default colors
COLOR = {
    "normal": "\033[0m",
    "unknown": "\033[1;35m",
    "header": "\033[1;33m",
    "log_line": "\033[1;30m",

    "series_normal": "\033[1;36m",
    "series_watching": "\033[1;34m",
    "series_dropped": "\033[1;31m",
    "seasonnum": "\033[1;35m",
    "epcount": "\033[1;34m",

    "score_top": "\033[1;32m",
    "score_high": "\033[0;32m",
    "score_normal": "\033[0;37m",
    "score_low": "\033[0;31m",
    "score_critical": "\033[1;31m",

    "stat_name": "\033[1;37m",
    "stat_year": "\033[1;36m",
    "stat_num": "\033[1;35m",
    "stat_perc": "\033[1;34m",
}

## Color names
COLORS_AVAILABLE = ["black", "red", "green", "yellow", 
                    "blue", "magenta", "cyan", "white",]

## Parse configuration
Config = ConfigParser()
Config.read([CONF_LOCATION,os.path.join(os.getcwd(), "anigraterc")])

## Load color configuration
if Config.has_option("appearance", "color_enabled") and \
   Config.get("appearance", "color_enabled") != "yes":
    for nm in COLOR:
        COLOR[nm] = ""
else:
    for nm in COLOR:
        if Config.has_option("color", nm):
            text = Config.get("color", nm)
            prop = 0
            col = 0

            for entry in text.split(","):
                if entry == "bold":
                    prop = 1
                elif entry in COLORS_AVAILABLE:
                    col = 30+COLORS_AVAILABLE.index(entry)

            if col == 0:
                COLOR[nm] = "\033[0m"
            else:
                COLOR[nm] = "\033[%d;%dm" % (prop, col)

## Templates for commandline
if Config.has_option("appearance", "unicode_enabled") and \
   Config.get("appearance", "unicode_enabled") != "yes":
    DATE_FORMAT = DATE_FORMAT.replace("{LINE}", "%(log_line)s.%(normal)s"%COLOR)

    DISPLAY_HEADER = \
    """\n  %(header)sSeries%(normal)s                                   | %(header)sWatched%(normal)s | %(header)sSeason%(normal)s | %(header)sRating%(normal)s """ % COLOR+\
    """\n ------------------------------------------+---------+--------+--------"""

    DISPLAY_FOOTER = """                                           |         |        |        \n  %d series displayed.\n"""

    DISPLAY_SERIES = """  %(title)s | %(epscurrent)s/%(epstotal)s | %(current)s | %(rating)s """

    DISPLAY_WATCHED = """  %(title)s season %(season)s to ep %(finishep)s | %(date)s """

    DISPLAY_HIST_HEADER = """\n  %(header)sHistory%(normal)s\n ----------------------------------------------------+------------------+-------""" % COLOR
    DISPLAY_HIST_FOOTER = """ ----------------------------------------------------+------------------+-------\n"""

    DISPLAY_LOG_HEADER = """%(log_line)s ..........................................+.........+........+........%(normal)s""" % COLOR
    DISPLAY_LOG = """  season %%(season)s to ep %%(finishep)s                       %(log_line)s|%(normal)s %%(date)s """ % COLOR
    DISPLAY_LOG_FOOTER = """%(log_line)s ..........................................+.........+........+........%(normal)s""" % COLOR
else:
    DATE_FORMAT = DATE_FORMAT.replace("{LINE}", "%(log_line)s│%(normal)s"%COLOR)

    DISPLAY_HEADER = \
    """\n  %(header)sSeries%(normal)s                                   │ %(header)sWatched%(normal)s │ %(header)sSeason%(normal)s │ %(header)sRating%(normal)s """ % COLOR+\
    """\n ──────────────────────────────────────────┼─────────┼────────┼────────"""

    DISPLAY_FOOTER = """                                           │         │        │        \n  %d series displayed.\n"""

    DISPLAY_SERIES = """  %(title)s │ %(epscurrent)s/%(epstotal)s │ %(current)s │ %(rating)s """

    DISPLAY_WATCHED = """  %(title)s season %(season)s to ep %(finishep)s │ %(date)s """

    DISPLAY_HIST_HEADER = """\n  %(header)sHistory%(normal)s\n ────────────────────────────────────────────────────┬──────────────────┬───────""" % COLOR
    DISPLAY_HIST_FOOTER = """ ────────────────────────────────────────────────────┴──────────────────┴───────\n"""

    DISPLAY_LOG_HEADER = """%(log_line)s ──────────────────────────────────────────┼─────────┴────────┼────────%(normal)s""" % COLOR
    DISPLAY_LOG = """  season %%(season)s to ep %%(finishep)s                       %(log_line)s│%(normal)s %%(date)s """ % COLOR
    DISPLAY_LOG_FOOTER = """%(log_line)s ──────────────────────────────────────────┼─────────┬────────┼────────%(normal)s""" % COLOR

DISPLAY_STATS = ("""
 %(header)sStatistics%(normal)s
 ==========

 %(header)sBy Rating%(normal)s
 ----------
"""+"\n".join(
 (" %%(stat_name)s%(rname)-12s %%(stat_num)s%%%%(rating_%(dy)d_num)5s series"+\
  "    %%(stat_perc)s%%%%(rating_%(dy)d_perc)5.1f%%%%%%%%") % {
      "dy": dy,
      "rname": dy if dy else "Unrated",
 } for dy in reversed(range(0,11)))+
"""

 %(header)sBy Year%(normal)s
 -----
%%(years)s %(header)sBy Weekday%(normal)s
 ----------
"""+"\n".join(
 (" %%(stat_name)s%(dayname)-12s %%(stat_num)s%%%%(day_%(dy)d_num)5s eps"+\
  "    %%(stat_perc)s%%%%(day_%(dy)d_perc)5.1f%%%%%%%%") % {
      "dy": dy,
      "dayname": ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")[dy-1]
 } for dy in range(1,8))+
"""
 
 %(header)sBy Hour%(normal)s
 -------
"""+"\n".join(
 (" %%(stat_name)s%(hr)02d.00-%(hrplus)02d.00  %%(stat_num)s%%%%(hour_%(hr)d_num)5s eps"+\
  "    %%(stat_perc)s%%%%(hour_%(hr)d_perc)5.1f%%%%%%%%") % {
    "hr": hr,
    "hrplus": hr+1,
 } for hr in range(0,24))+
"""
%(normal)s
""") % COLOR

DISPLAY_YEAR_STATS = (""" %(stat_year)s%%(year_num)s%(normal)s
 ~~~~
 %(stat_name)sEpisodes%(normal)s  %%(total_num)s
 %(stat_name)sMinutes%(normal)s   %%(total_min)s min
 %(stat_name)sDays%(normal)s      %%(total_day).3f days

"""+"\n".join(
 (" %%(stat_name)s%(mname)-12s %%(stat_num)s%%%%(month_%(m)d_num)5s eps"+\
  "    %%(stat_perc)s%%%%(month_%(m)d_perc)5.1f%%%%%%%%") % {
      "m": m,
      "mname": ("January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November",
                "December")[m-1]
 } for m in range(1,13))+"\n\n")% COLOR
# }}}

# {{{ Help
HELPTEXT = """
Usage: %s [COMMAND] [ARGS...]: [SELECTOR]
Manage a list of watched anime or television series.

Database:
    By default anigrate uses an sqlite database in $HOME/.anigrate/db,
    see the example anigraterc for all the other possibilities.

Commands:
    initdb
        Initialise the database with all the necessary tables.

    list: [selector]
        List all series matched by [selector].
        If no selector is given, match all series.

    log: (selector)
        Show a detailed log for series matching (selector).

    hist [num]: [selector]
        Show the last [num] watched episode entries for series matching
        [selector]. Num defaults to 15, matches all series if no selector
        is specified.

    add [category] [watched[/total][*seasons]] [rating] [duration]: (name)
        Add a new series entry with name specified by (name).
        Optionally, you can specify the category, duration, amount of episodes
        watched, amount of episodes total, amount of seasons and rating.

        Note that if you specify to create multiple seasons, every season will
        have the same watched and total amounts you specified here.

    category [category]: (selector)
        Mark all series matched by (selector) as having category [category].

    remove: (selector)
        Completely remove any series that match (selector).

    rate <score>: (selector)
        Rate all series matched by (selector) with <score>.

    [un]drop: (selector)
        Mark all series matched by (selector) as dropped or not dropped.

    length <length>: (selector)
        Set the active season's length in episodes.

    duration <time>: (selector)
        Set the average duration of an episode in series matching (selector).
        This is used to calculate total watching time, defaults to 24 minutes
        per episode for every series.

    time: [selector]
        Get the total watching time spent on series matching [selector].
        If no selector is given the total time for all series is given.

    watch [num]: (selector)
        Change the episodes watched count. Without [num] specified it will be
        incremented by one. Using specifiers like "+3" or "-2" you can increment
        or decrement the watched count by that number. Specifying an absolute
        number will watch up to that episode or remove everything from that
        episode on. Watch always uses the currently active season.

    season add [watched[/total]] [num]: (selector)
        Add a new season, if num is specified the season number is set to that, 
        otherwise it will default to one more than the previous season.

        Optionally, you can specify the watched/total episode amounts to be set 
        for this season.

    season remove [num]: (selector)
        Remove the season with number [num] from a series. If num is not
        specified the currently active season will be removed.

    season length <season> <length>: (selector)
        Set a season's length in episodes.

    season active <num>: (selector)
        Set season with number <num> as the active season. Can be a relative 
        offset like +1 or -2.

    stats: [selector]
        Show a list of various statistics about the times and dates episodes
        of series matching [selector] have been watched. If no selector is
        given, show statistics about all series.


    match: [selector]
        Output a simple no-nonsense list of series matched by [selector],
        useful for piping into other binaries. If no selector is given, match
        all series.

    info: [selector]
        Output a no-nonsense list with information on all series matched by
        [selector], useful for piping into other binaries. If no selector is 
        given, match all series.

        Outputs series info in format:
            title\tcurrent_episode\ttotal_episodes\tcurrent_season\trating

        ie. each item is separated by a tab character for easy parsing.


    import [file] [format] [category]
        Import a list of series to put in the database from a file.
        If file is not specified or is "-", the file will be read from stdin.
        If category is specified, all new series imported will be set
        to that category. This allows for easier organisation.
        See "Database Formats" for an explanation on how those work.

    export [file] [format]: [selector]
        Export a list of series from in the database to a file.
        If file is not specified or is "-", the file will be output to stdout.
        If a selector is given, only series matching that selector will be 
        exported.
        See "Database Formats" for an explanation on how those work.


    runserver [type] [host] [port]
        Run a server displaying an html public list on [host] (default: localhost)
        and [port] (default: 4310). Type is set to "http" by default and will 
        host a simple http webserver not meant to be used in production. If 
        flup is installed, you can additionally specify [type] to be "fcgi", 
        "scgi" or "ajp" and it will host a server with that protocol.

        Note that the main anigrate binary can also be used as a wsgi script 
        and it will display the same html public list.

        You can specify any selector to display a list for in the address by 
        separating the terms with slashes. For example:

            http://localhost:4310/=anime/+watching/@title

    help
        Show this help message.

Selectors:
    Selectors are used to find series to act upon. In its most basic form, a 
    selector is simply the name of a series or the beginning of a name of a 
    series (note that the selector will match any series that start with the 
    specified name). Within the selector, the options listed below can be given.

    +finished/+completed, +watching, +dropped, +undropped:
        Put any of these in a separate argument anywhere in the selector and it 
        will only match series that satisfy the condition.

    =<category>
        Will only match series in the specified category.

    %%exact
        When specified, only match series that exactly match the full selector.

    %%contains
        When specified, match all series containing the selector.

    %%suffix
        When specified, match all series that end with the selector.

    %%prefix
        Default behaviour: match all series that start with the selector.

    @rating, @activity, @watched, @title
        Set field to sort by, you can sort by series rating, series latest 
        activity, amount of episodes watched and title respectively.

    @split
        Default sort method, sorts by activity but splits into watching,
        finished and dropped groups first.

Database Formats:
    Database formats are used to determine how to read or write series
    from or to a file, the following format specifiers are available:

    csv
        Uses a simple csv file with series titles and other info.

    anidb
        Uses anidb.net's csv-minimal MyList export template.

    myanimelist  [IMPORT ONLY]
        Uses myanimelist.net's xml export format.
        When importing from myanimelist be sure to uncompress it before feeding
        it to anigrate; you can use pipes for this. For example:
          $ gunzip -c animelist_0000_-_0000.xml.gz | anigrate import - myanimelist

Examples:
    Here are some example use cases, note that every selector specifier or 
    command can be shortened to its smallest non-ambiguous prefix.

    anigrate list
        List all series in the database.

    anigrate li: =anime
        List all series in category "anime".

    anigrate li: +w
        List only series currently being watched.

    anigrate list: +c @r
        List all completed series sorted by the rating given.

    anigrate add anime: Mushishi
        Add a new series in category "anime" with name "Mushishi".

    anigrate watch: Mushishi
        Increment the watched count on the "Mushishi" series by one.

    anigrate w +3: Mus
        Increment the watched count by three on series prefixed by "Mus".
        ie. This command would match "Mus[shishi]" and thus increment
        that by three.

    anigrate season add: Mushishi
        Add a new season to series "Mushishi".

    anigrate se act 1: Mushishi
        Set season "1" as the active season on series "Mushishi".

    anigrate length 26: Mushishi
        Set the currently active season on series "Mushishi" as being
        26 episodes long.
"""

VERSIONTEXT = """Anigrate """+str(ANIGRATE_VERSION)+""" <"""+ANIGRATE_URI+""">

Copyright (C) 2009-2010 Lucas de Vries <lucas@glacicle.org>
License WTFPL: <http://sam.zoy.org/wtfpl>"""
# }}}

# {{{ Weblist CSS
CSS_NAME = ""
CSS_MTIME = 0

WEBLIST_CSS = """
body {
    font-family: sans-serif; 
    font-size: 0.9em;
    background: white;
    color: black;
}

#header > h1, #header > h2 {
    margin: 0;
    text-align: center;
}

#header > span {
    display: block;
    text-align: center;
    font-size: 0.8em;
}

#header a:link, #header a:visited {
    text-decoration: none;
    color: blue;
}

#gentime {
    font-size: 0.7em;
    padding-top: 1em;
    text-align: center;
}

#info {
    margin: 1em auto 0;
    border: 1px solid #cccccc;
    background: #f7f7f7;
    display: table;
    font-size: 0.8em;
    min-width: 20em;
}

#info ul {
    margin: 0;
    padding: .5em;
}

#info li {
    margin: 0;
    list-style: none;
    display: table-row;
}

#info li span {
    display: table-cell;
}

#info li span:first-child {
    min-width: 10em;
    font-weight: bold;
}

#quicklinks, #legend {
    margin: 1em auto 0;
    border: 1px solid #cccccc;
    background: #f7f7f7;
    display: table;
}

#quicklinks ul {
    margin: 0;
    padding: 0;
}

#quicklinks li {
    list-style: square inside;
    margin: 0;
    padding-top: 0.3em;
    font-size: 0.8em;
}

#quicklinks a:link, #quicklinks a:visited {
    color: black;
    text-decoration: none;
}

#quicklinks a:hover {
    text-decoration: underline;
}

#quicklinks > div {
    display: table-row;
}

#quicklinks > div > div {
    padding: 1em;
    min-width: 8em;
    display: table-cell;
}

#quicklinks h3 {
    margin: 0;
}

#log {
    margin: 1em;
}

#log table {
    padding: 0;
    width: 100%;
}

#log tr {
    list-style: none;
    width: 100%;
}

#log td {
    padding: .3em;
}

#log td:nth-child(2):not(:last-child) {
    text-align: center;
}

#log tr:nth-child(odd) {
    background: #e7e7e7;
}

#log tr:nth-child(even) {
    background: #f7f7f7;
}

#log a:link, a:visited {
    color: black;
    text-decoration: none;
}

#log a:hover {
    text-decoration: underline;
}

#legend {
    padding: .4em;
    font-size: .7em;
}

#legend div:last-child {
    margin-top: 1em;
}

#legend h4 {
    margin: 0;
    padding: 0;
}

#series ul {
    -moz-column-count: 4;
    -webkit-column-count: 4;
    column-count: 4;
    margin: 1em 0;
    padding: 0;
}

#series li {
    display: block;
    list-style: none;
    margin: 0;
    position: relative;
}

#series li a:first-child {
    padding: .5em;
    display: block;
}

#series li a:last-child {
    position: absolute;
    font-size: 0.7em;
    font-weight: bold;
    padding-left: 0.5em;
    padding-bottom: 0.4em;

    bottom: 0.6em;
    right: .6em;

    visibility: hidden;
}

#series li:hover a:last-child {
    visibility: visible;
}

#series li a:link, li a:visited {
    color: black;
    text-decoration: none;
}

#series li a:hover {
    text-decoration: underline;
}

@media screen and (-webkit-min-device-pixel-ratio:0) {
    /** Webkit does _not_ like position:relative inside
        a css3 column list. **/

    #series li {
        position: static;
    }

    #series li a:last-child {
        position: static;
        float: right;
        margin-top: -2.3em;
        margin-right: .6em;
        top: none;
        right: none;
    }
}

div.year {
    float: left;
    width: 50%;
    padding-bottom: 1em;
}

div#weekdays {
    padding-bottom: 1.3em;
}

div#hours {
    clear: both;
}

div.year strong {
    clear: left;
    min-width: 30%;
}

#stats h3 {
    margin: 0;
}

#stats h2 {
    margin: 1em 0 .3em 0;
}

#stats h2:first-child {
    margin-top: 0;
}

div.year strong, div.year span {
    float: left;
    display: block;
    font-size: .7em;
}

#stats table {
    width: 100%;
    clear: both;
    padding-right: 0.5em;
}

#stats tr.stat:nth-child(even) {
    background: #f7f7f7;
}

#stats tr.stat:nth-child(odd) {
    background: #e7e7e7;
}

#stats td {
    padding: .3em;
}

#stats td:first-child {
    width: 25%;
}

#stats td:last-child {
    width: 50%;
    padding: 0;
}

#stats tr.stat:nth-child(even) td:last-child > div {
    background: #99ff80;
    padding: .3em;
}

#stats tr.stat:nth-child(odd) td:last-child > div {
    background: #ffe680;
    padding: .3em;
}

.f_0 { font-weight: bold; }
.d_1, .d_1 a, #series li.d_1 a { color: #cc3030; }

.r_10, #series li.r_10 a:last-child { background: #80ff80; }
.r_9,  #series li.r_9 a:last-child  { background: #99ff80; }
.r_8,  #series li.r_8 a:last-child  { background: #b3ff80; }
.r_7,  #series li.r_7 a:last-child  { background: #ccff80; }
.r_6,  #series li.r_6 a:last-child  { background: #e6ff80; }
.r_5,  #series li.r_5 a:last-child  { background: #ffff80; }
.r_4,  #series li.r_4 a:last-child  { background: #ffe680; }
.r_3,  #series li.r_3 a:last-child  { background: #ffcc80; }
.r_2,  #series li.r_2 a:last-child  { background: #ffb380; }
.r_1,  #series li.r_1 a:last-child  { background: #ff9980; }
.r_0,  #series li.r_0 a:last-child  { background: #ffffff; }

#log td.r_0 { background: none; }
"""
# }}}

# {{{ Weblist HTML
# {{{ List page
PAGE_HTML = """
<!DOCTYPE html>

<html lang='en-GB'>
  <head>
    <title>%(title)s: %(selector)s</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" href="%(cssname)s" type="text/css" media="screen" charset="utf-8">
  </head>
  <body>
    %(headerinc)s

    <div id='header'>
      <h1>%(title)s</h1>
      <h2>%(selector)s</h2>
      <span>
        <a href="%(uri)s/hist/%(urlselector)s">(history)</a>
        <a href="%(uri)s/stats/%(urlselector)s">(statistics)</a>
      </span>
      <span>%(numseries)d total. %(time_days).1f days</span>
    </div>

    <div id='quicklinks'>
        <div>
            <div>
                <h3>Category:</h3>
                <ul>
                    <li><a href="%(uri)s/=all">all categories</a></li>
                    %(categories)s
                </ul>
            </div>

            <div>
                <h3>Display:</h3>
                <ul>
                    <li><a href="%(cat_uri)s/@title">everything</a></li>
                    <li><a href="%(cat_uri)s/+watching">watching</a></li>
                    <li><a href="%(cat_uri)s/+finished/@rating">finished</a></li>
                    <li><a href="%(cat_uri)s/+dropped">dropped</a></li>
                </ul>
            </div>

            <div>
                <h3>Sort:</h3>
                <ul>
                    <li><a href="%(nosort_uri)s/@title">title</a></li>
                    <li><a href="%(nosort_uri)s/@rating">rating</a></li>
                    <li><a href="%(nosort_uri)s/@activity">activity</a></li>
                    <li><a href="%(nosort_uri)s/@split">split</a></li>
                </ul>
            </div>
        </div>
    </div>

    <div id='series'>
      <ul>
        %(series)s
      </ul>
    </div>

    <div id="legend">
        <div>
          <h4>Background</h4>
          Greener: Rated higher.<br/>
          Redder: Rated lower.<br/>
          White: Unrated.<br/>
        </div>

        <div>
          <h4>Text</h4>
          Bold: Currently watching.<br/>
          Red: Dropped.<br/>
        </div>
    </div>

    %(footerinc)s
  </body>
</html>
"""

SERIES_HTML = """<li class="r_%(rate)d d_%(dropped)d f_%(finished)d"><a href="%(link)s">%(title)s</a><a href="%(loglink)s">S%(season)d %(watched)s/%(total)s</a></li>"""

CATEGORY_HTML = """<li><a href="%(link)s">%(title)s</a></li>"""
# }}}

# {{{ Log Page
LOG_PAGE_HTML = """
<!DOCTYPE html>

<html lang='en-GB'>
  <head>
  <title>%(title)s: %(selector)s</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" href="%(cssname)s" type="text/css" media="screen" charset="utf-8">
  </head>
  <body>
    %(headerinc)s

    <div id="header">
      <h1>%(title)s</h1>
      <h2>%(selector)s</h2>
      <span>
          <a href="%(uri)s/%(urlselector_list)s">(list)</a>
          <a href="%(uri)s/stats/%(urlselector)s">(statistics)</a>
      </span>
    </div>

    %(info)s

    <div id="log">
        <table>
            %(log)s
        </table>
    </div>

    %(footerinc)s
  </body>
</html>
"""

INFO_HTML = """
    <div id="info" class="dropped_%(dropped)d finished_%(finished)d">
        <ul>
            <li><span>Latest</span> <span>S%(current)s %(watched)s/%(total)s</span></li>
            <li><span>Seasons</span> <span>%(seasons)s</span></li>
            <li><span>Duration</span> <span>%(duration)s min/ep</span></li>
            <li><span>Rating</span> <span>%(rating)s</span></li>
        </ul>
    </div>
"""


LOG_HTML = """<tr><td>season <strong>%(season)s</strong> to ep <strong>%(episode)s</strong></td> <td>%(date)s</td></tr>"""

HIST_HTML = """<tr><td class="r_%(rating)d f_%(finished)d d_%(dropped)d series"><a href="%(link)s">%(series)s</a></td><td><a href="%(uri)s/=%(category)s">%(category)s</a></td><td><a href="%(loglink)s">season <strong>%(season)s</strong> to ep <strong>%(episode)s</strong></a></td> <td>%(date)s</td></tr>"""

# }}}

# {{{ Stats page
STATS_PAGE_HTML = """
<!DOCTYPE html>

<html lang='en-GB'>
  <head>
    <title>%(title)s: %(selector)s</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" href="%(cssname)s" type="text/css" media="screen" charset="utf-8">

    <style type='text/css'>

    </style>
  </head>
  <body>
    %(headerinc)s

    <div id='header'>
      <h1>%(title)s</h1>
      <h2>%(selector)s</h2>
      <span>
        <a href="%(uri)s/%(urlselector)s">(list)</a>
        <a href="%(uri)s/hist/%(urlselector)s">(history)</a>
      </span>
    </div>

    <div id='stats'>
    <h2>Ratings</h2>
    <div id='ratings'>
    <table>
    """+"\n".join((" <tr class='stat'>"+\
     "<td>%(rname)s</td> <td>%%(rating_%(r)d_num)5s series</td>"+\
     " <td><div style='width: %%(rating_%(r)d_perc)s%%%%'>%%(rating_%(r)d_perc)5.1f%%%%</div></td>") % {
        "r": r,
        "rname": r if r else "Unrated",
     } for r in reversed(range(0,11)))+"""
     </table>
     </div>

    <h2>Watch Time</h2>
    <div id='weekdays'>
    <h3>Weekdays</h3>
    <table>
    """+"\n".join((" <tr class='stat' title='%(dayname)s: %%(day_%(dy)d_num)s eps, %%(day_%(dy)d_min)s minutes, %%(day_%(dy)d_day).3f days.'>"+\
     "<td>%(dayname)s</td> <td>%%(day_%(dy)d_num)5s eps</td>"+\
     " <td><div style='width: %%(day_%(dy)d_perc)s%%%%'>%%(day_%(dy)d_perc)5.1f%%%%</div></td>") % {
          "dy": dy,
          "dayname": ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")[dy-1]
     } for dy in range(1,8))+"""
     </table>
    </div>

    <div id='years'>
        %(years)s
    </div>
     
    <div id='hours'>
    <h3>Hours</h3>
    <table>
    """+"\n".join((" <tr class='stat' title='%(hr)02d.00-%(hrplus)02d.00: %%(hour_%(hr)d_num)s eps, %%(hour_%(hr)d_min)s minutes, %%(hour_%(hr)d_day).3f days.'>"+\
     "<td>%(hr)02d.00-%(hrplus)02d.00</td> <td>%%(hour_%(hr)d_num)5s eps</td>"+\
     " <td><div style='width: %%(hour_%(hr)d_perc)s%%%%'>%%(hour_%(hr)d_perc)5.1f%%%%</div></td>") % {
        "hr": hr,
        "hrplus": hr+1,
     } for hr in range(0,24))+"""
    </table>
    </div>
    </div>

    %(footerinc)s
  </body>
</html>
"""

YEAR_HTML = """
<div class="year" id="year_%(year_num)s">
<h3>%(year_num)s</h3>
<strong>Total Episodes</strong> <span>%(total_num)s eps</span>
<strong>Total Minutes</strong> <span>%(total_min)s min</span>
<strong>Total Days</strong> <span>%(total_day).3f days</span>

<table>
"""+"\n".join(
(" <tr class='stat' title='%(mname)s %%(year_num)s: %%(month_%(m)d_num)s eps, %%(month_%(m)d_min)s minutes, %%(month_%(m)d_day).3f days.'>"+\
     "<td>%(mname)s</td> <td>%%(month_%(m)d_num)5s eps</td>"+\
     " <td><div style='width: %%(month_%(m)d_perc)s%%%%'>%%(month_%(m)d_perc)5.1f%%%%</div></td>") % {
      "m": m,
      "mname": ("January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November",
                "December")[m-1]
 } for m in range(1,13))+ """
</table>
</div>
"""
# }}}

# {{{ Default header and footer
HEADER_HTML = ''
FOOTER_HTML = '<div id="gentime">page generated by <a href="'+ANIGRATE_URI+'">anigrate v'+str(ANIGRATE_VERSION)+'</a> in {{GENTIME}}s</div>'

HEADER_NAME = ''
FOOTER_NAME = ''

HEADER_MTIME = ''
FOOTER_MTIME = ''
# }}}

# }}}

# {{{ Models
Base = declarative_base()
Session = sessionmaker()

# {{{ Series
class Series(Base):
    """An entire series."""
    __tablename__ = "series"
    id = Column(Integer, primary_key=True)
    title = Column(String(255))
    rating = Column(Integer, default=0)
    current = Column(Integer)
    ctime = Column(DateTime)
    mtime = Column(DateTime)
    dropped = Column(Boolean, default=False)
    category = Column(String(255), default="")
    duration = Column(Integer, default=24)

    seasontotal = Column(Integer, default=1)
    epscurrent = Column(Integer, default=0)
    epstotal = Column(Integer, default=0)
    epsall = Column(Integer, default=0)
    finished = Column(Boolean, default=False)

    @property
    def current_season(self):
        return self.season_bynum(self.current)

    def season_bynum(self, num):
        for season in self.seasons:
            if season.num == num:
                return season

    def getlink(self):
        """Get the link to open for this series."""
        if Config.has_option("link", self.category):
            return Config.get("link", self.category) % self.title
        elif Config.has_option("link", "default"):
            return Config.get("link", "default") % self.title
        else:
            return DEFAULT_LINK % self.title

    def eval_finished(self):
        """Evaluate whether the series is finished."""
        self.finished = True
        self.seasontotal = 0
        self.epsall = 0

        for season in self.seasons:
            if season.current_watched < season.episode_total \
            or season.episode_total == 0:
                self.finished = False

            self.epsall += season.current_watched
            if season.num == self.current:
                self.epscurrent = season.current_watched
                self.epstotal = season.episode_total

            self.seasontotal += 1

        return self.finished
# }}}

# {{{ Season
class Season(Base):
    """One season of a series."""
    __tablename__ = "seasons"
    id = Column(Integer, primary_key=True)
    num = Column(Integer)

    series_id = Column(ForeignKey("series.id"))
    series = relation(Series, primaryjoin=(series_id == Series.id), backref="seasons")

    episode_total = Column(Integer, default=0)
    current_watched = Column(Integer, default=0)
# }}}

# {{{ Watched
class Watched(Base):
    """A 'watched episodes' event attached to a season."""
    __tablename__ = "watched"
    id = Column(Integer, primary_key=True)

    season_id = Column(ForeignKey("seasons.id"))
    seasonnum = Column(Integer)
    season = relation(Season, primaryjoin=(season_id == Season.id),
                              backref="watched")

    series_id = Column(ForeignKey("series.id"))
    series = relation(Series, primaryjoin=(series_id == Series.id),
                              backref="watched")

    time = Column(DateTime)

    startep = Column(Integer)
    finishep = Column(Integer)
# }}}
# }}}

# {{{ Utility functions
commands = {}

# {{{ command
def command(name=None, cmds=None):
    """Register a function as a command."""
    def cmd(func):
        # Get command dict
        if cmds == None:
            global commands
            cm = commands
        else:
            cm = cmds

        cm[(name or func.__name__)] = func
        return func

    return cmd
# }}}

# {{{ getcommand
def getcommand(name, cmds=None):
    """Get a command by name."""
    # Get command dict
    if cmds == None:
        global commands
        cmd = commands
    else:
        cmd = cmds

    # Exact match
    if name in cmd:
        return cmd[name]

    # Prefix match
    candidate = filter(lambda x: x.startswith(name), cmd.keys())

    if len(candidate) == 1:
        return cmd[candidate[0]]
    elif candidate:
        return candidate
    else:
        return None
# }}}

# {{{ dbbind
def dbbind():
    """Bind the sqlalchemy database engine and return the session."""
    # Try to read config
    if not hasattr(Session, "_Bound") or not Session._Bound:
        if Config.has_option("database", "uri"):
            engine = create_engine(Config.get("database", "uri"),
                               pool_size=100, pool_recycle=7200)
            Base.metadata.bind = engine
            Session._Bound = True
            Session.configure(bind=engine)
        else:
            # Default location
            if not os.path.exists(CONF_DIR):
                os.mkdir(CONF_DIR)

            engine = create_engine('sqlite:///'+DB_LOCATION)
            Base.metadata.bind = engine
            Session.configure(bind=engine)
            Session._Bound = True

            if not os.path.exists(DB_LOCATION):
                initdb(session=Session())

    return Session()
# }}}

# {{{ getselection
def getselection(session, selector, list=True):
    """Get all anime matching a selector"""
    q = session.query(Series)
    selector = selector[:]
    mode = "prefix"
    sort = False

    for opt in selector[:]:
        if opt.startswith("+"):
            if "+finished".startswith(opt) or "+completed".startswith(opt):
                q = q.filter(Series.finished == True)
                q = q.filter(Series.dropped == False)
                selector.remove(opt)
            elif "+watching".startswith(opt):
                q = q.filter(Series.finished == False)
                q = q.filter(Series.dropped == False)
                selector.remove(opt)
            elif "+dropped".startswith(opt):
                q = q.filter(Series.dropped == True)
                selector.remove(opt)
            elif "+undropped".startswith(opt):
                q = q.filter(Series.dropped == False)
                selector.remove(opt)
        elif opt.startswith("%"):
            mode = opt[1:]
            selector.remove(opt)
        elif opt.startswith("="):
            if opt[1:] != "all":
                q = q.filter(Series.category == opt[1:])
            selector.remove(opt)
        elif opt.startswith("@"):
            if "@rating".startswith(opt):
                selector.remove(opt)
                sort = True
                q = q.order_by(Series.rating.desc())
            elif "@activity".startswith(opt):
                selector.remove(opt)
                sort = True
                q = q.order_by(Series.mtime.desc())
            elif "@watched".startswith(opt):
                selector.remove(opt)
                sort = True
                q = q.order_by(Series.epscurrent.desc())
            elif "@title".startswith(opt):
                selector.remove(opt)
                sort = True
                q = q.order_by(Series.title.asc())
            elif "@split".startswith(opt):
                selector.remove(opt)
                sort = True
                q = q.order_by(Series.dropped.asc(), Series.finished.asc(), Series.mtime.desc())

    # Default sort order
    if not sort:
        default_sort = Config.get("anigrate", "default_sort") if Config.has_option("anigrate", "default_sort") else "split"

        if default_sort == "rating":
            q = q.order_by(Series.rating.desc())
        elif default_sort == "activity":
            q = q.order_by(Series.mtime.desc())
        elif default_sort == "watched":
            q = q.order_by(Series.epscurrent.desc())
        elif default_sort == "title":
            q = q.order_by(Series.title.asc())
        elif default_sort == "split":
            q = q.order_by(Series.dropped.asc(), Series.finished.asc(), Series.mtime.desc())

    if selector:
        selector = " ".join(selector)

        if "exact".startswith(mode):
            q = q.filter(Series.title.ilike(selector))
        elif "contains".startswith(mode):
            q = q.filter(Series.title.contains(selector))
        elif "suffix".startswith(mode):
            q = q.filter(Series.title.endswith(selector))
        else:
            q = q.filter(Series.title.startswith(selector))

    return q.all() if list else q
# }}}

# {{{ padstr
def padstr(string, pad, right=False):
    # Convert to string
    string = str(string)

    # Padd
    if right:
        string = " "*(pad-len(string))+string
    else:
        string = string+" "*(pad-len(string))

    return string
# }}}

# {{{ gettime
def gettime(selection):
    """Get total time watching for this selection."""
    total = 0

    for sel in selection:
        total += sel.epsall*sel.duration

    totaldays = total/float(1440)
    return (total, totaldays)
# }}}

# {{{ getstats
def getstats(session, selection):
    """ Get a dictionary with various statistics. """
    stats = {
        "count": selection.count(),
        "year": {},
    }

    # Make sure the selection is loaded
    sel = [selection.all()]
    totalseries = len(sel[0])

    # Create watched query
    if selection:
        seltable = selection.subquery()
        q = session.query(Watched).join((seltable, Watched.series_id == seltable.c.id))
    else:
        q = session.query(Watched)

    # Fill dictionary
    def fill(amn, time, key, dt):
        if key+"_num" not in dt:
            dt[key+"_num"] = 0
            dt[key+"_min"] = 0
            dt[key+"_day"] = 0

        dt[key+"_num"] += amn
        dt[key+"_min"] += time
        dt[key+"_day"] += time/float(1440)

    [fill(0, 0, "day_"+str(i), stats) for i in range(1,8)]
    [fill(0, 0, "month_"+str(i), stats) for i in range(1,13)]
    [fill(0, 0, "hour_"+str(i), stats) for i in range(0,24)]
    [fill(0, 0, "rating_"+str(i), stats) for i in range(0,11)]
    fill(0, 0, "total", stats)

    # Gather stats
    for watched in q.all():
        amn = watched.finishep - watched.startep
        time = session.query(Series).get(watched.series_id).duration * amn

        if amn == 0:
            print(watched.series.title, watched.time, watched.finishep, watched.startep)

        if watched.time.year not in stats['year']:
            stats['year'][watched.time.year] = {}
            stats['year'][watched.time.year]['year'] = watched.time.year

        # Year specific totals
        fill(amn, time, "total", stats['year'][watched.time.year])
        fill(amn, time, "month_"+str(watched.time.month), stats['year'][watched.time.year])

        # Global totals
        fill(amn, time, "total", stats)
        fill(amn, time, "day_"+watched.time.strftime("%u").lower(), stats)
        fill(amn, time, "hour_"+str(watched.time.hour), stats)
        fill(amn, time, "month_"+str(watched.time.month), stats)

    for series in sel[0]:
        fill(1, 1, "rating_"+str(series.rating), stats)

    # Gather percentages
    percs = {}

    # Totals
    for nm in stats:
        if not nm.startswith("total") and nm.endswith("_min"):
            perc = "_".join(nm.split("_")[:-1])+"_perc"

            if nm.startswith("rating_"):
                percs[perc] = stats[nm]/float(totalseries)*100 if totalseries else 0
            else:
                percs[perc] = stats[nm]/float(stats["total_min"])*100 if stats["total_min"] else 0
    stats.update(percs)

    for yr in stats['year']:
        yearpercs = {}

        for i in range(1,13):
            if "month_"+str(i)+"_num" not in stats['year'][yr]:
                stats['year'][yr]["month_"+str(i)+"_num"] = 0
                stats['year'][yr]["month_"+str(i)+"_min"] = 0
                stats['year'][yr]["month_"+str(i)+"_day"] = 0

        for nm in stats['year'][yr]:
            if not nm.startswith("total") and nm.endswith("_min"):
                perc = "_".join(nm.split("_")[:-1])+"_perc"
                yearpercs[perc] = stats['year'][yr][nm]/float(stats['year'][yr]["total_min"])*100 if stats['year'][yr] else 0
        stats['year'][yr].update(yearpercs)

    return stats
# }}}

# }}}

# {{{ Display functions
# {{{ dispseries
def dispseries(sel, display=True):
    """Display a line for a series."""
    data = {
        "title": sel.title,
        "current": padstr(sel.current, 6),
        "epscurrent": padstr(sel.epscurrent, 3),
        "epstotal": padstr(sel.epstotal, 3, right=True),
        "rating": padstr(sel.rating, 6),
    }

    # Color rating
    if sel.rating == 0:
        data['rating'] = COLOR['unknown']+"??    "+COLOR['normal']
    elif sel.rating <= 4:
        data['rating'] = COLOR['score_critical']+data['rating']+COLOR['normal']
    elif sel.rating <= 5:
        data['rating'] = COLOR['score_low']+data['rating']+COLOR['normal']
    elif sel.rating >= 10:
        data['rating'] = COLOR['score_top']+data['rating']+COLOR['normal']
    elif sel.rating >= 8:
        data['rating'] = COLOR['score_high']+data['rating']+COLOR['normal']
    else:
        data['rating'] = COLOR['score_normal']+data['rating']+COLOR['normal']

    # Dropped note
    if sel.dropped:
        data['title'] = "(dropped) "+data['title']

    # Truncate series
    if len(data['title']) > 40:
        data['title'] = data['title'][:37]+"..."

    data['title'] = padstr(data['title'], 40)

    if sel.epstotal == 0:
        data['epstotal'] = COLOR['unknown']+" ??"+COLOR['normal']

    # Mark watching/dropped
    if sel.dropped:
        data['title'] = COLOR['series_dropped']+data['title']+COLOR['normal']
        data['current'] = COLOR['series_dropped']+data['current']+COLOR['normal']
        data['epscurrent'] = COLOR['series_dropped']+data['epscurrent']
        data['epstotal'] = data['epstotal']+COLOR['normal']
    elif not sel.finished:
        data['title'] = COLOR['series_watching']+data['title']+COLOR['normal']
        data['current'] = COLOR['series_watching']+data['current']+COLOR['normal']
        data['epscurrent'] = COLOR['series_watching']+data['epscurrent']
        data['epstotal'] = data['epstotal']+COLOR['normal']
    else:
        data['title'] = COLOR['series_normal']+data['title']+COLOR['normal']
        data['current'] = COLOR['series_normal']+data['current']+COLOR['normal']
        data['epscurrent'] = COLOR['series_normal']+data['epscurrent']
        data['epstotal'] = data['epstotal']+COLOR['normal']

    if display:
        print(DISPLAY_SERIES % data)
    else:
        return DISPLAY_SERIES % data
# }}}

# {{{ dispwatched
def dispwatched(sel, watched, display=True, template=None):
    """Display a watched episode string"""
    data = {
        "title": sel.title,
        "season": padstr(watched.seasonnum, 2),
        "startep": padstr(watched.startep, 2),
        "finishep": padstr(watched.finishep, 2),
        "date": watched.time.strftime(DATE_FORMAT),
    }

    # Truncate series
    if len(data['title']) > 31:
        data['title'] = data['title'][:28]+"..."

    data['title'] = padstr(data['title'], 31)

    # Color title
    if sel.rating != 0:
        if sel.rating <= 4:
            data['title'] = COLOR['score_critical']+data['title']+COLOR['normal']
        elif sel.rating <= 5:
            data['title'] = COLOR['score_low']+data['title']+COLOR['normal']
        elif sel.rating >= 10:
            data['title'] = COLOR['score_top']+data['title']+COLOR['normal']
        elif sel.rating >= 8:
            data['title'] = COLOR['score_high']+data['title']+COLOR['normal']
        else:
            data['title'] = COLOR['score_normal']+data['title']+COLOR['normal']

    # Color season
    data['season'] = COLOR['seasonnum']+str(data['season'])+COLOR['normal']

    # Color episode
    data['startep'] = COLOR['epcount']+str(data['startep'])+COLOR['normal']
    data['finishep'] = COLOR['epcount']+str(data['finishep'])+COLOR['normal']

    if template is None:
        template = DISPLAY_WATCHED

    if display:
        print(template % data)
    else:
        return template % data
# }}}
# }}}

# {{{ Weblist
# {{{ WSGI Application
def application(environ, start_response):
    # Save time
    start_time = time.time()

    if environ.has_key("SCRIPT_NAME") and environ.get("SCRIPT_NAME"):
        # Use request URI
        uri = unquote(environ.get("REQUEST_URI", ""))

        # Strip script name
        uri = uri[len(environ.get("SCRIPT_NAME", "")):]

        # Strip query args
        uri = uri.split("?")[0].lstrip("/")
    else:
        # Use PATH_INFO
        uri = environ.get("PATH_INFO").lstrip("/")

    # Get selector
    selector = uri.strip("/").split("/")

    # Empty selector
    if not selector or selector == ['']:
        selector = []

    # Uri sanity checks
    if not uri: uri = '/'
    elif uri[-1] != "/": uri += "/"

    # Default headers
    mime = "text/html"
    headers = []

    # Connect to db
    session = dbbind()

    # {{{ CSS configuration
    cssname = environ.get("SCRIPT_NAME", "/").rstrip("/")+"/css/master.css"

    if Config.has_option("weblist", "css"):
        cssconf = Config.get("weblist", "css")

        if cssconf.startswith("uri:"):
            # Use a literal uri
            cssname = cssconf[4:]
        else:
            global WEBLIST_CSS,CSS_NAME,CSS_MTIME

            # Strip file prefix
            if cssconf.startswith("file:"):
                cssconf = cssconf[5:]

            # Check if we should load the file
            if os.path.exists(cssconf):
                mtime = os.path.getmtime(cssconf)

                if CSS_NAME != cssconf or CSS_MTIME != mtime:
                    CSS_MTIME = mtime
                    CSS_NAME = cssconf
                    WEBLIST_CSS = "".join(open(cssconf).readlines())
    # }}}

    # {{{ Header/footer configuration
    if Config.has_option("weblist", "header"):
        global HEADER_HTML,HEADER_NAME,HEADER_MTIME
        headerconf = Config.get("weblist", "header")

        # Check if we should load the file
        if os.path.exists(headerconf):
            mtime = os.path.getmtime(headerconf)

            if HEADER_NAME != headerconf or HEADER_MTIME != mtime:
                HEADER_MTIME = mtime
                HEADER_NAME = headerconf
                HEADER_HTML = "".join(open(headerconf).readlines())

    if Config.has_option("weblist", "footer"):
        global FOOTER_HTML,FOOTER_NAME,FOOTER_MTIME
        footerconf = Config.get("weblist", "footer")

        # Check if we should load the file
        if os.path.exists(footerconf):
            mtime = os.path.getmtime(footerconf)

            if FOOTER_NAME != footerconf or FOOTER_MTIME != mtime:
                FOOTER_MTIME = mtime
                FOOTER_NAME = footerconf
                FOOTER_HTML = "".join(open(footerconf).readlines())
    # }}}

    # Check for page to display
    if uri == "css/master.css/":
        # {{{ CSS
        data = WEBLIST_CSS
        headers.append(("Cache-Control", "max-age=3600"))
        mime = "text/css"
        # }}}
    elif uri.startswith("log/"):
        # {{{ Log page
        # Remove log argument
        selector = ["%exact", "/".join(selector[1:])]

        # Get selection
        selection = getselection(session, selector)

        # Check selection
        if not selection:
            data = "Error: series matching selector not found."
        else:
            series = selection[0]
            data = {
                "cssname": cssname,
                "headerinc": HEADER_HTML,
                "footerinc": FOOTER_HTML,

                "title": Config.get("weblist","title_log") \
                        if Config.has_option("weblist","title_log") \
                        else DEFAULT_TITLE_LOG,
                "uri": environ.get("SCRIPT_NAME", "/").rstrip("/"),
                "selector": series.title,
                "urlselector": quote("%exact/"+series.title),
                "urlselector_list": quote("="+series.category),
                "log": "",
            }

            data['info'] = INFO_HTML % {
                "seasons": len(series.seasons),
                "current": str(series.current),
                "watched": str(series.epscurrent),
                "total": str(series.epstotal) if series.epstotal else "??",
                "rating": str(series.rating) if series.rating else "??",
                "duration": str(series.duration),
                "dropped": series.dropped,
                "finished": series.finished,
            }

            
            # Get watch log
            for watch in session.query(Watched).filter(
                Watched.series == series
            ).order_by(Watched.time.desc(), Watched.seasonnum.desc(),
                       Watched.finishep.desc()):
                data['log'] += LOG_HTML % {
                    "season": watch.seasonnum,
                    "episode": watch.finishep,
                    "date": watch.time.strftime(DATE_FORMAT_HTML),
                }

            # Generate page
            data = LOG_PAGE_HTML % data
        # }}}
    elif uri.startswith("hist/"):
        # {{{ History page
        # Remove hist argument
        selector = selector[1:]

        # Get selection
        selection = getselection(session, selector, list=False)
        data = {
            "cssname": cssname,
            "headerinc": HEADER_HTML,
            "footerinc": FOOTER_HTML,

            "title": Config.get("weblist","title_log") \
                    if Config.has_option("weblist","title_log") \
                    else DEFAULT_TITLE_LOG,
            "uri": environ.get("SCRIPT_NAME", "/").rstrip("/"),
            "log": "",
            "info": "",
            
            "selector": (" ".join(selector) if selector else "All Series")\
                            .replace(" %e", ""),
            "urlselector": quote("/".join(selector)),
            "urlselector_list": quote("/".join(selector)),
        }

        limit = Config.get("weblist","history_size") if \
                Config.has_option("weblist","history_size") else \
                30

        selection = selection.subquery()

        for watch, series in session.query(Watched, Series).join(
                (selection, Watched.series_id == selection.c.id)
            ).filter(Series.id == Watched.series_id).order_by(
                Watched.time.desc(), Watched.seasonnum.desc(),
                   Watched.finishep.desc()
            ).limit(limit):
            data['log'] += HIST_HTML % {
                "series": series.title,
                "rating": series.rating,
                "finished": series.finished,
                "dropped": series.dropped,
                "season": watch.seasonnum,
                "episode": watch.finishep,
                "category": series.category,
                "date": watch.time.strftime(DATE_FORMAT_HTML),

                "uri": data["uri"],
                "link": series.getlink(),
                "loglink": data['uri']+"/log/"+quote(series.title),
            }

        # Generate page
        data = LOG_PAGE_HTML % data
        # }}}
    elif uri.startswith("stats/"):
        # {{{ Stats page
        # Remove stats argument
        selector = selector[1:]
        selname = " ".join(selector) if selector else "All Series"

        # Get selection
        selection = getselection(session, selector, list=False)

        # Page data dictionary
        data = {
            "cssname": cssname,
            "headerinc": HEADER_HTML,
            "footerinc": FOOTER_HTML,

            "title": Config.get("weblist","title_stats") if Config.has_option("weblist","title_stats") else DEFAULT_TITLE_STATS,
            "selector": selname,
            "urlselector": quote("/".join(selector)),
            "uri": environ.get("SCRIPT_NAME", "/").rstrip("/"),
        }

        # Get statistics
        data.update(getstats(session, selection))
        data['year_num'] = "All Years"
        data['years'] = YEAR_HTML % data

        for year in data['year']:
            data['year'][year]['year_num'] = year
            data['years'] += YEAR_HTML % data['year'][year]

        # Generate page
        data = STATS_PAGE_HTML % data
        # }}}
    else:
        # {{{ List page
        # Default selector
        if not selector and Config.has_option("weblist", "default"):
            selector = Config.get("weblist", "default").split()

        # Page data dictionary
        data = {
            "cssname": cssname,
            "headerinc": HEADER_HTML,
            "footerinc": FOOTER_HTML,

            "series": "",
            "seriestime": 1.56,
            "urlselector": quote("/".join(selector)),
            "selector": " ".join(selector) if selector else "All Series",
            "title": Config.get("weblist","title_list") if Config.has_option("weblist","title_list") else DEFAULT_TITLE_LIST,
            "uri": environ.get("SCRIPT_NAME", "/").rstrip("/"),
        }

        # Category uri
        ## Find category in selector
        cat = None
        for sel in selector:
            if sel.startswith("="):
                cat = sel[1:]

        ## Build uri
        if cat:
            data['cat_uri'] = data['uri']+"/="+cat
        else:
            data['cat_uri'] = data['uri']

        # Unsorted uri
        data['nosort_uri'] = quote("/".join(
            [data['uri']]+[x for x in selector if not x.startswith("@")]
        ))

        # Category list
        data['categories'] = ''

        for cat in session.query(Series).group_by(Series.category).all():
            data['categories'] += CATEGORY_HTML % {
                "title": cat.category,
                "link": data['uri']+"/="+cat.category,
            }

        # Retrieve series
        selection = getselection(session, selector)
        data['time_minutes'], data['time_days'] = gettime(selection)
        data['numseries'] = len(selection)

        # Add series to list
        for series in selection:
            data['series'] += SERIES_HTML % {
                "title": series.title,
                "rate": series.rating,
                "dropped": series.dropped,
                "finished": series.finished,
                "season": series.current,
                "link": series.getlink(),
                "loglink": data['uri']+"/log/"+quote(series.title),

                "watched": str(series.epscurrent),
                "total": str(series.epstotal) if series.epstotal else "??",
            }

        # Generate page
        data = PAGE_HTML % data
        # }}}

    # Close session
    session.close()

    # Get encodings
    has_gzip = [enc for enc in environ.get("HTTP_ACCEPT_ENCODING","").split(",") 
                if enc.split(";")[0].strip() == "gzip"]

    # Send response
    if (Config.has_option("weblist", "gzip") and Config.get("weblist", "gzip") == "no") or not has_gzip:
        start_response('200 OK', [('Content-Type', mime)]+headers)
        return data.replace("{{GENTIME}}", str(round(time.time()-start_time, 3)), 1)
    else:
        start_response('200 OK', [('Content-Type', mime), ('Content-Encoding', 'gzip')]+headers)
        strfile = StringIO.StringIO()
        gzfile = gzip.GzipFile(None, 'wb', 6, fileobj=strfile)
        gzfile.write(data.replace("{{GENTIME}}", str(round(time.time()-start_time, 3)), 1))
        gzfile.close()
        return strfile.getvalue()
# }}}

# {{{ runserver
@command()
def runserver(arg, selector):
    if not arg:
        arg = ["http"]

    if len(arg) >= 3:
        try:
            int(arg[2])
        except:
            return "Error: port (argument 3) is not a valid integer."

        bind = (arg[1], int(arg[2]))
    else:
        bind = ("localhost", 4310)

    if arg[0] in ('fcgi','scgi','ajp'):
        if HAVE_FLUP:
            if arg[0] == "fcgi":
                from flup.server.fcgi import WSGIServer
            elif arg[0] == "scgi":
                from flup.server.scgi import WSGIServer
            elif arg[0] == "ajp":
                from flup.server.ajp import WSGIServer

            print("serving %s list on %s port %d." % (arg[0], bind[0], bind[1]))
            WSGIServer(application,
                bindAddress=bind
            ).run()
        else:
            return "Error: flup is required to be installed for fcgi, scgi or ajp servers."
    elif arg[0] == 'http':
        from wsgiref.simple_server import make_server
        print("serving http list on %s port %d." % bind)
        srv = make_server(bind[0], bind[1], application)
        srv.serve_forever()
    else:
        servers = ['http']
        if HAVE_FLUP: servers += ['fcgi','scgi','ajp']
        return "Error: invalid server type. Available: %s." % ", ".join(servers)
# }}}
# }}}

# {{{ Commands
# {{{ initdb
@command()
def initdb(arg=None, selector=None, session=None):
    """Initialise the database for use."""
    if not session:
        dbbind()
    Base.metadata.create_all()
# }}}

# {{{ add
@command()
def add(arg, selector):
    if not selector:
        return "Error: selector required."

    # Bind database
    session = dbbind()
    selector = " ".join(selector)

    # Don't create if one already exists
    check_exists = session.query(Series).filter(Series.title.ilike(selector))

    if len(arg) > 0:
        check_exists = check_exists.filter(Series.category == arg[0])
    else:
        check_exists = check_exists.filter(Series.category == "")

    if check_exists.all():
        return "Error: A series with this name already exists in this category..."

    # Create a new series
    series = Series(title=selector, current=1)
    series.ctime = datetime.datetime.now()
    series.mtime = datetime.datetime.now()

    print("Adding: %s..." % series.title)

    ## Category
    if len(arg) > 0:
        series.category = arg[0]

    if len(arg) > 2:
        try:
            series.rating = int(arg[2])
        except:
            return "Error: rating is not a valid number."

    if len(arg) > 3:
        try:
            series.duration = int(arg[3])
        except:
            return "Error: duration is not a valid number."

    session.add(series)

    ## Parse episodes
    if len(arg) > 1:
        watched = arg[1]
        total = 0
        seasons = 1

        if "*" in watched:
            try:
                watched, seasons = watched.split("*")
            except:
                return "Error: episodes in invalid format."

        if "/" in watched:
            try:
                watched, total = watched.split("/")
            except:
                return "Error: episodes in invalid format."

        try:
            watched = int(watched)
            total = int(total)
            seasons = int(seasons)
        except:
            return "Error: episodes in invalid format."

        if total == 0 and seasons > 1:
            total = watched

        for i in range(seasons):
            season = Season()
            season.num = i+1
            season.series = series
            season.episode_total = total
            season.current_watched = watched
            session.add(season)

            if watched > 0:
                w = Watched()
                w.series = series
                w.season = season
                w.time = datetime.datetime.now()
                w.startep = 0
                w.finishep = watched
                w.seasonnum = season.num
                session.add(w)

        series.current = seasons
        series.eval_finished()
    else:
        ## First season
        season = Season(num=1)
        season.series = series
        session.add(season)

    session.commit()
# }}}

# {{{ remove
@command()
def remove(arg, selector):
    """Remove a series in totality."""
    if not selector:
        return "Error: selector required."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    if not selection:
        return "Error: no series match selector."

    for sel in selection:
        print("Removing: %s..." % sel.title)

        for season in sel.seasons:
            session.query(Watched).filter(Watched.season == season)\
                                  .delete(False)
            session.delete(season)

        session.delete(sel)

    session.commit()
# }}}

# {{{ rate
@command()
def rate(arg, selector):
    """Set the rating/score for a series."""
    if not selector:
        return "Error: selector required."

    if not arg:
        return "Error: rating required."

    try:
        score = int(arg[0])
    except:
        return "Error: rating is not a valid number."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    for sel in selection:
        print("rating=%d: %s..." %(score, sel.title))
        sel.rating = score

    session.commit()
# }}}

# {{{ category
@command()
def category(arg, selector):
    """Set the category for a series."""
    if not selector:
        return "Error: selector required."

    if not arg:
        return "Error: category required."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    for sel in selection:
        print("category=%s: %s..." %(arg[0], sel.title))
        sel.category = arg[0]

    session.commit()
# }}}

# {{{ [un]drop
@command()
def drop(arg, selector):
    """Drop a series."""
    if not selector:
        return "Error: selector required."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)


    if not selection:
        return "Error: no series match selector."

    for sel in selection:
        print("dropped: %s..." % sel.title)
        sel.dropped = True

    session.commit()

@command()
def undrop(arg, selector):
    """Undrop a series."""
    if not selector:
        return "Error: selector required."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    for sel in selection:
        print("undropped: %s..." % sel.title)
        sel.dropped = False

    session.commit()
# }}}

# {{{ length
@command()
def length(arg, selector):
    """Set the current season's length for a series."""
    if not selector:
        return "Error: selector required."

    if not arg:
        return "Error: length required."

    try:
        length = int(arg[0])
    except:
        return "Error: length is not a valid number."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    for sel in selection:
        season = sel.current_season
        season.episode_total = length

        print("season %d length = %d: %s..."%
                (season.num, length, sel.title))

        sel.eval_finished()

    session.commit()
# }}}

# {{{ duration
@command()
def duration(arg, selector):
    """Set the duration per episode for a series."""
    if not selector:
        return "Error: selector required."

    if not arg:
        return "Error: duration required."

    try:
        duration = int(arg[0])
    except:
        return "Error: duration is not a valid number."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    for sel in selection:
        sel.duration = duration

        print("duration=%d: %s..."%
                (duration, sel.title))

    session.commit()
# }}}

# {{{ time
@command(name="time")
def totaltime(arg, selector):
    """Set the duration per episode for a series."""
    # Bind database
    session = dbbind()
    selection = getselection(session, selector)
    time = gettime(selection)

    print("Total time spent watching:")
    print("%.1f days = %d minutes" % (time[1], time[0]))
# }}}

# {{{ season
global seasoncmd
seasoncmd = {}

@command()
def season(arg, selector):
    """Run a season command"""
    if not arg:
        return "Error: season command required."

    global seasoncmd
    cmd = getcommand(arg[0], cmds=seasoncmd)

    if callable(cmd):
        return cmd(arg[1:], selector)
    elif cmd:
        print("Error: ambiguous season command, available:")
        print("\n".join(("  %s season "+x)%sys.argv[0] for x in cmd))
        exit(1)
    else:
        return "Error: Invalid Season Command: %s" % arg[0]

# {{{ active
@command(cmds=seasoncmd)
def active(arg, selector):
    """Set the rating/score for a series."""
    if not selector:
        return "Error: selector required."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    # Get number
    if arg:
        try:
            rel = arg[0][0] in ('+', '-')
            num = int(arg[0])
        except:
            return "Error: season number is not a valid number."
    else:
        return "Error: season number required."

    if not selection:
        return "Error: no series match selector."

    for sel in selection:
        sn = sel.current+num if rel else num

        if sn < 1:
            print("Error: season number for series %s too low (%d)."
                    % (sel.title, sn))
            continue

        season = sel.season_bynum(sn)

        if not season:
            print("Error: season %d for series %s doesn't exist."
                    % (sn, sel.title))
            continue

        print("activate season = %d: %s..." % (sn, sel.title))
        sel.current = season
        sel.eval_finished()

    session.commit()
# }}}

# {{{ add
@command(cmds=seasoncmd)
def add(arg, selector):
    """Set the rating/score for a series."""
    if not selector:
        return "Error: selector required."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    ## Parse episodes
    watched = 0
    total = 0

    if arg:
        if "/" in arg[0]:
            try:
                watched, total = map(int, arg[0].split("/"))
            except:
                return "Error: episodes in invalid format, ignoring."
        else:
            try:
                watched = int(arg[0])
            except:
                return "Error: episodes in invalid format, ignoring."

    # Get number
    if len(arg) > 1:
        try:
            num = int(arg[1])
        except:
            return "Error: season number is not a valid number."
    else:
        num = None

    ## Error on selector
    if not selection:
        return "Error: no series match selector."

    for sel in selection:
        sn = sel.current+1 if num==None else num

        if sn < 1:
            print("Error: season number for series %s too low (%d)."
                    % (sel.title, sn))
            continue

        if sel.season_bynum(sn):
            print("Error: season %d for series %s already exists."
                    % (sn, sel.title))
            continue

        season = Season()
        season.series = sel
        season.num = sn
        season.current_watched = watched
        season.episode_total = total
        sel.current = season.num

        print("Adding season %d: %s..." % (sn, sel.title))
        session.add(season)

        if watched:
            w = Watched()
            w.series = sel
            w.season = season
            w.time = datetime.datetime.now()
            w.seasonnum = season.num
            w.startep = 0
            w.finishep = watched
            session.add(w)

        sel.eval_finished()

    session.commit()
# }}}

# {{{ remove
@command(cmds=seasoncmd)
def remove(arg, selector):
    """Remove a season from a series."""
    if not selector:
        return "Error: selector required."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    # Get number
    if arg:
        try:
            num = int(arg[0])
        except:
            return "Error: season number is not a valid number."
    else:
        num = None

    if not selection:
        return "Error: no series match selector."

    for sel in selection:
        sn = sel.current if num==None else num

        if sn < 1:
            print("Error: season number for series %s too low (%d)."
                    % (sel.title, sn))
            continue

        # Find season
        season = sel.season_bynum(sn)

        # Check for existence
        if not season:
            print("Error: season %d for series %s doesn't exist."
                    % (sn, sel.title))
            continue

        # Delete watched
        session.query(Watched).filter(Watched.season == season).delete(False)

        # Delete
        print("Removing season %d: %s..." % (sn, sel.title))
        session.delete(season)

        if sel.current == sn:
            # Get new season number
            sn -= 1
            while sn > 0 and not sel.season_bynum(sn):
                sn -= 1
            sel.current = sn

        sel.eval_finished()


    session.commit()
# }}}

# {{{ length
@command(cmds=seasoncmd)
def length(arg, selector):
    """Set the current season's length for a series."""
    if not selector:
        return "Error: selector required."

    if len(arg) < 2:
        return "Error: insufficient arguments."

    try:
        num = int(arg[0])
    except:
        return "Error: season number is not a valid number."

    try:
        length = int(arg[0])
    except:
        return "Error: length is not a valid number."

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    for sel in selection:
        season = sel.season_bynum(num)
        season.episode_total = length

        print("season %d length = %d: %s..."%
                (num, length, sel.title))

        sel.eval_finished()

    session.commit()
# }}}

# }}}

# {{{ watch
@command()
def watch(arg, selector):
    """Set the watched count for the currently active season."""
    if not selector:
        return "Error: selector required."

    if arg:
        try:
            rel = arg[0][0] in ('+', '-')
            num = int(arg[0])
        except:
            return "Error: watched amount is not a valid number."
    else:
        rel = True
        num = 1

    # Filter out silly numbers
    if rel and num == 0:
        return "Error: invalid watched amount: 0."
    elif not rel and num < 0:
        return "Error: invalid watched amount: %d." % num

    # Bind database
    session = dbbind()
    selection = getselection(session, selector)

    # Display header
    print(DISPLAY_HEADER)

    for sel in selection:
        season = sel.current_season
        neww = season.current_watched+num if rel else num

        if neww < 0:
            return "Error: invalid watched amount %d: %s." % (neww, sel.title)
        if season.episode_total > 0 and neww > season.episode_total:
            return "Error: watched amount %d is more than season length %d: %s."\
                     % (neww, season.episode_total, sel.title)

        if neww < season.current_watched:
            watched = session.query(Watched).filter(
                Watched.season == season
            ).order_by(Watched.finishep.desc()).all()

            for inst in watched:
                if inst.startep >= neww:
                    session.delete(inst)
                elif inst.finishep > neww:
                    inst.finishep = neww
                    break
        elif neww > season.current_watched:
            watched = Watched()
            watched.season = season
            watched.series = sel
            watched.startep = season.current_watched
            watched.finishep = neww
            watched.seasonnum = season.num
            watched.time = datetime.datetime.now()
            session.add(watched)

        sel.mtime = datetime.datetime.now()
        season.current_watched = neww
        sel.eval_finished()

        # Display series
        dispseries(sel)

        # Display log
        watched = session.query(Watched).filter(
            Watched.series == sel
        ).order_by(Watched.time.desc()).all() 

        if watched:
            # Display header
            print(DISPLAY_LOG_HEADER)

            for watch in watched:
                dispwatched(sel, watch, template=DISPLAY_LOG)

            # Display footer
            print(DISPLAY_LOG_FOOTER)


    # Display footer
    print(DISPLAY_FOOTER%len(selection))

    session.commit()
# }}}

# {{{ match
@command()
def match(arg, selector):
    """Simply display series matching a selector."""
    # Bind database
    session = dbbind()

    # Get selection
    selection = getselection(session, selector)

    # Display header
    for sel in selection:
        print(sel.title)
# }}}

# {{{ info
@command()
def info(arg, selector):
    """Simply display info about series matching a selector."""
    # Bind database
    session = dbbind()

    # Get selection
    selection = getselection(session, selector)

    # Display header
    for sel in selection:
        print("%s\t%d\t%d\t%d\t%d" %
            (sel.title, sel.epscurrent, sel.epstotal,
             sel.current, sel.rating))
# }}}

# {{{ list
@command()
def list(arg, selector):
    """Display series matching a selector."""
    # Bind database
    session = dbbind()

    # Get selection
    selection = getselection(session, selector)

    # Display header
    print(DISPLAY_HEADER)

    for sel in selection:
        dispseries(sel)

    # Display footer
    print(DISPLAY_FOOTER%len(selection))
# }}}

# {{{ hist
@command()
def hist(arg, selector):
    """Display watched history."""
    # Bind database
    session = dbbind()

    # Number of entries
    if arg:
        try:
            num = int(arg[0])
        except:
            return "Error: history amount is not a valid number."
    else:
        num = 20

    # Build query
    q = session.query(Watched, Series)

    # Selection
    if selector:
        selection = getselection(session, selector, list=False).subquery()
        q = q.join((selection, Watched.series_id == selection.c.id))

    # Sort
    q = q.filter(Series.id == Watched.series_id)
    q = q.order_by(Watched.time.desc())

    # Limit
    if num:
        q = q.limit(num)

    # Display header
    print(DISPLAY_HIST_HEADER)

    for watch, series in q.all():
        dispwatched(series, watch)

    # Display footer
    print(DISPLAY_HIST_FOOTER)
# }}}

# {{{ stats
@command()
def stats(arg, selector):
    """Display statistics."""
    # Bind database
    session = dbbind()

    # Build query
    q = session.query(Watched)

    # Selection
    selection = getselection(session, selector, list=False)

    # Get statistics
    stats = getstats(session, selection)
    stats['year_num'] = "All"
    stats['years'] = DISPLAY_YEAR_STATS % stats

    for year in stats['year']:
        stats['year'][year]['year_num'] = year
        stats['years'] += DISPLAY_YEAR_STATS % stats['year'][year]

    # Print statistics
    print(DISPLAY_STATS%stats)
# }}}

# {{{ log
@command()
def log(arg, selector):
    """Display lines matching a selector."""
    # Bind database
    session = dbbind()

    # Get selection
    selection = getselection(session, selector)

    # Display header
    print(DISPLAY_HEADER)

    for sel in selection:
        dispseries(sel)
        watched = session.query(Watched).filter(
            Watched.series == sel
        ) .order_by(
            Watched.time.desc(),
            Watched.seasonnum.desc(),
            Watched.finishep.desc()
        ).all()

        if watched:
            # Display header
            print(DISPLAY_LOG_HEADER)

            for watch in watched:
                dispwatched(sel, watch, template=DISPLAY_LOG)

            # Display footer
            print(DISPLAY_LOG_FOOTER)

    # Display footer
    print(DISPLAY_FOOTER%len(selection))
# }}}

# {{{ Import/Export
## {{{ Formats
def anidb_import(session, fd, category):
    reader = csv.reader(fd, delimiter=';', quotechar='"')
    reader.next()

    for row in reader:
        # Check row size
        if not row:
            continue
        elif len(row) != 5:
            print("ERROR: Malformed row, expected 5 columns. skipping...")
            continue

        # Check whether it already exists
        check_exists = session.query(Series).filter(
            Series.title.ilike(row[0])
        ).filter(
            Series.category == category
        )

        if check_exists.all():
            print("ERROR: A series with name `%s` already exists in category `%s`. skipping..." % (row[0], category))
            continue

        # Create series
        series = Series(title=row[0], current=1, category=category)
        series.ctime = series.mtime = datetime.datetime.now()
        session.add(series)

        # Get watched / total amount
        try:
            has, total  = map(int, row[2].split(" / ", 1))
            current, total_has = map(int, row[3].split(" / ", 1))
        except:
            print("ERROR: Wrong format, expected `$current / $total`. skipping...")
            continue

        # Create season
        season = Season(num=1, series=series,
            episode_total=total, current_watched=current)
        session.add(season)

        # Create watch log
        if current > 0:
            watched = Watched(series=series, season=season,
                    time=datetime.datetime.now(), startep=0,
                    finishep=current, seasonnum=1)
            session.add(watched)

        series.eval_finished()
        print("Adding series `%s`." % row[0])

    session.commit()

def anidb_export(session, selection, fd):
    writer = csv.writer(fd, delimiter=';', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(["Name", "Year", "Eps", "Seen", "Size"])

    for sel in selection:
        writer.writerow([
            sel.title,
            0,
            "%s / %s" % (sel.epscurrent, sel.epstotal),
            "%s / %s" % (sel.epscurrent, sel.epstotal),
            0
        ])

def csv_import(session, fd, category):
    reader = csv.reader(fd, delimiter=',', quotechar='"')
    reader.next()

    for row in reader:
        # Check for correct row size
        if not row:
            continue
        elif len(row) != 9:
            print("ERROR: Malformed row, expected 9 columns. skipping...")
            continue

        # Get correct category
        category = category if category else row[1]

        # Check if the series exists already
        check_exists = session.query(Series).filter(
            Series.title.ilike(row[0])
        ).filter(
            Series.category == category
        )

        if check_exists.all():
            print("ERROR: A series with name `%s` already exists in category `%s`. skipping..." % (row[0], category))
            continue

        # Get integer data
        try:
            dropped = bool(int(row[2]))
            rating = int(row[3])
            season = int(row[4])
            current = int(row[5])
            total = int(row[6])
            duration = int(row[8])
        except:
            print("ERROR: Wrong format, expected integer. skipping...")
            continue

        # Create the series
        series = Series(title=row[0], current=season, rating=rating, duration=duration, dropped=dropped, category=category)
        series.ctime = series.mtime = datetime.datetime.now()
        session.add(series)

        seasonobj = Season(num=season, series=series,
            episode_total=total, current_watched=current)
        session.add(seasonobj)

        if current > 0:
            watched = Watched(series=series, season=seasonobj,
                    time=datetime.datetime.now(), startep=0,
                    finishep=current, seasonnum=season)
            session.add(watched)

        series.eval_finished()
        print("Adding series `%s`." % row[0])

    session.commit()

def csv_export(session, selection, fd):
    writer = csv.writer(fd, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    writer.writerow(["Name", "Category", "Dropped", "Rating", "Current_Season", "Current_Seen", "Current_Total", "All_Total", "Duration"])

    for sel in selection:
        writer.writerow([
            sel.title,
            sel.category,
            int(sel.dropped),
            sel.rating,
            sel.current,
            sel.epscurrent,
            sel.epstotal,
            sel.epsall,
            sel.duration,
        ])

def mal_import(session, fd, category):
    import xml.dom.minidom
    dom = xml.dom.minidom.parse(fd)

    for anime in dom.getElementsByTagName("anime"):
        # Get values
        try:
            title = anime.getElementsByTagName("series_title")[0].firstChild.nodeValue
            total = int(anime.getElementsByTagName("series_episodes")[0].firstChild.nodeValue)
            current = int(anime.getElementsByTagName("my_watched_episodes")[0].firstChild.nodeValue)
            rating = int(anime.getElementsByTagName("my_score")[0].firstChild.nodeValue)
            dropped = anime.getElementsByTagName("my_status")[0].firstChild.nodeValue == "Dropped"
        except:
            print("ERROR: Wrong format. skipping...")

        # Check whether it already exists
        check_exists = session.query(Series).filter(
            Series.title.ilike(title)
        ).filter(
            Series.category == category
        )

        if check_exists.all():
            print("ERROR: A series with name `%s` already exists in category `%s`. skipping..." % (title, category))
            continue

        # Create series
        series = Series(title=title, current=1, rating=rating, dropped=dropped, category=category)
        series.ctime = series.mtime = datetime.datetime.now()
        session.add(series)

        # Create season
        season = Season(num=1, series=series,
            episode_total=total, current_watched=current)
        session.add(season)

        # Create watch log
        if current > 0:
            watched = Watched(series=series, season=season,
                    time=datetime.datetime.now(), startep=0,
                    finishep=current, seasonnum=1)
            session.add(watched)

        series.eval_finished()
        print("Adding series `%s`." % title)

    session.commit()

## }}}

@command(name="import")
def db_import(arg, selector):
    # Bind database
    session = dbbind()

    # Get file
    if len(arg) >= 1 and arg[0] != "-":
        try:
            fd = open(arg[0], "r")
        except IOError:
            return "Error opening input file"
    else:
        fd = sys.stdin

    # Get format
    if len(arg) >= 2:
        format = arg[1]
    else:
        format = "csv"

    # Get category
    if len(arg) >= 3:
        category = arg[2]
    else:
        category = ""

    # Export
    try:
        if format == "csv":
            csv_import(session, fd, category)
        elif format == "anidb":
            anidb_import(session, fd, category)
        elif format == "myanimelist":
            mal_import(session, fd, category)
    except:
        print("ERROR: There was a problem reading the file, is it in the correct format?")

    fd.close()

@command(name="export")
def db_export(arg, selector):
    # Bind database
    session = dbbind()

    # Get selection
    selection = getselection(session, selector)

    # Get file
    if len(arg) >= 1 and arg[0] != "-":
        fd = open(arg[0], "w")
    else:
        fd = sys.stdout

    # Get format
    if len(arg) >= 2:
        format = arg[1]
    else:
        format = "csv"

    # Export
    if format == "csv":
        csv_export(session, selection, fd)
    elif format == "anidb":
        anidb_export(session, selection, fd)

    fd.close()

# }}}

# }}}

# {{{ Main function
def main():
    # Retrieve arguments
    arg = sys.argv[1:]

    # Intercept help
    if not arg or arg[0] in ("help", "--help", "-h"):
        print(HELPTEXT%sys.argv[0])
        return

    # Intercept version
    if arg[0] in ("version", "--version", "-v"):
        print(VERSIONTEXT)
        return

    # Get selector and arguments
    ## Check if there exists a selector
    if filter(lambda x: x.endswith(":"), arg):
        selector = []
        newargs = addto = []

        # Build selector
        for i,x in enumerate(arg):
            addto.append(x)

            if x.endswith(":"):
                addto = selector

        # Remove colon
        arg = newargs
        arg[-1] = arg[-1][:-1]
    else:
        selector=[]

    # Call the command
    cmd = getcommand(arg[0])

    if callable(cmd):
        res = cmd(arg[1:], selector)

        if res:
            # An error occured
            print(res)
            exit(1)
    elif cmd:
        print("Error: ambiguous command, available:")
        print("\n".join(("  %s "+x)%sys.argv[0] for x in cmd))
        exit(1)
    else:
        print("Error: Invalid Command: %s" % arg[0])
        print(HELPTEXT%sys.argv[0])
        exit(1)
# }}}

# Call main function
if __name__ == '__main__':
    main()
# vim: set fdm=marker :
